// WARNING: This output format is intended for human consumers only
// and is subject to change without notice. Knock yourself out.
fn main() -> () {
    let mut _0: ();
    let mut _1: [usize; 5];
    let mut _3: bool;
    let mut _4: usize;
    let mut _5: usize;
    let _6: usize;
    let mut _7: bool;
    let mut _8: usize;
    let mut _9: (usize, bool);
    let mut _11: &[usize];
    let mut _12: &[usize; 5];
    let mut _13: usize;
    scope 1 {
        debug a => _1;
        let mut _2: usize;
        scope 2 {
            debug i => _2;
            let _10: std::option::Option<&usize>;
            scope 3 {
                debug result => _10;
            }
        }
    }

    bb0: {
        _1 = [const 1_usize, const 2_usize, const 3_usize, const 4_usize, const 5_usize];
        _2 = const 0_usize;
        goto -> bb1;
    }

    bb1: {
        _4 = copy _2;
        _3 = Lt(move _4, const 5_usize);
        switchInt(move _3) -> [0: bb5, otherwise: bb2];
    }

    bb2: {
        _5 = copy _2;
        _6 = copy _2;
        _7 = Lt(copy _6, const 5_usize);
        assert(move _7, "index out of bounds: the length is {} but the index is {}", const 5_usize, copy _6) -> [success: bb3, unwind continue];
    }

    bb3: {
        _1[_6] = move _5;
        _8 = copy _2;
        _9 = AddWithOverflow(copy _8, const 1_usize);
        assert(!move (_9.1: bool), "attempt to compute `{} + {}`, which would overflow", move _8, const 1_usize) -> [success: bb4, unwind continue];
    }

    bb4: {
        _2 = move (_9.0: usize);
        goto -> bb1;
    }

    bb5: {
        _12 = &_1;
        _11 = move _12 as &[usize] (PointerCoercion(Unsize, Implicit));
        _13 = copy _2;
        _10 = core::slice::<impl [usize]>::get::<usize>(move _11, move _13) -> [return: bb6, unwind continue];
    }

    bb6: {
        return;
    }
}
