Path,Library,Start_line,End_line,Unchecked Func,Checked Func,Safety Conditions,Safety Condition Category,User visible,Flag
../../refs/rust/library/alloc/src/boxed/convert.rs,"Box<T:dyn Any, A:Allocator>",394,400,"    pub unsafe fn downcast_unchecked<T: Any>(self) -> Box<T, A> {
        debug_assert!(self.is::<T>());
        unsafe {
            let (raw, alloc): (*mut dyn Any, _) = Box::into_raw_with_allocator(self);
            Box::from_raw_in(raw as *mut T, alloc)
        }
    }
","pub fn downcast<T: Any>(self) -> Result<Box<T, A>, Self> {
        if self.is::<T>() { unsafe { Ok(self.downcast_unchecked::<T>()) } } else { Err(self) }
    }",The caller has to promise that the type T is the right T.,type,exposed,
../../refs/rust/library/alloc/src/boxed/convert.rs,"Box<T: dyn Any + Send, A: Allocator>",453,459,"    pub unsafe fn downcast_unchecked<T: Any>(self) -> Box<T, A> {
        debug_assert!(self.is::<T>());
        unsafe {
            let (raw, alloc): (*mut (dyn Any + Send), _) = Box::into_raw_with_allocator(self);
            Box::from_raw_in(raw as *mut T, alloc)
        }
    }
","pub fn downcast<T: Any>(self) -> Result<Box<T, A>, Self> {
        if self.is::<T>() { unsafe { Ok(self.downcast_unchecked::<T>()) } } else { Err(self) }
    }",The caller has to promise that the type T is the right T.,type,exposed,
../../refs/rust/library/alloc/src/boxed/convert.rs," Box<T:dyn Any + Send + Sync, A: Allocator>",512,519,"    pub unsafe fn downcast_unchecked<T: Any>(self) -> Box<T, A> {
        debug_assert!(self.is::<T>());
        unsafe {
            let (raw, alloc): (*mut (dyn Any + Send + Sync), _) =
                Box::into_raw_with_allocator(self);
            Box::from_raw_in(raw as *mut T, alloc)
        }
    }
","pub fn downcast<T: Any>(self) -> Result<Box<T, A>, Self> {
        if self.is::<T>() { unsafe { Ok(self.downcast_unchecked::<T>()) } } else { Err(self) }
    }",The caller has to promise that the type T is the right T.,type,exposed,
../../refs/rust/library/alloc/src/collections/btree/map.rs,CursorMutKey,3191,3218,"    pub unsafe fn insert_after_unchecked(&mut self, key: K, value: V) {
        let edge = match self.current.take() {
            None => {
                // Tree is empty, allocate a new root.
                // SAFETY: We have no other reference to the tree.
                let root = unsafe { self.root.reborrow() };
                debug_assert!(root.is_none());
                let mut node = NodeRef::new_leaf(self.alloc.clone());
                // SAFETY: We don't touch the root while the handle is alive.
                let handle = unsafe { node.borrow_mut().push_with_handle(key, value) };
                *root = Some(node.forget_type());
                *self.length += 1;
                self.current = Some(handle.left_edge());
                return;
            }
            Some(current) => current,
        };

        let handle = edge.insert_recursing(key, value, self.alloc.clone(), |ins| {
            drop(ins.left);
            // SAFETY: The handle to the newly inserted value is always on a
            // leaf node, so adding a new root node doesn't invalidate it.
            let root = unsafe { self.root.reborrow().as_mut().unwrap() };
            root.push_internal_level(self.alloc.clone()).push(ins.kv.0, ins.kv.1, ins.right)
        });
        self.current = Some(handle.left_edge());
        *self.length += 1;
    }
","pub fn insert_after(&mut self, key: K, value: V) -> Result<(), UnorderedKeyError> {
        if let Some((prev, _)) = self.peek_prev() {
            if &key <= prev {
                return Err(UnorderedKeyError {});
            }
        }
        if let Some((next, _)) = self.peek_next() {
            if &key >= next {
                return Err(UnorderedKeyError {});
            }
        }
        unsafe {
            self.insert_after_unchecked(key, value);
        }
        Ok(())
    }","必须保证BTreeMap不变量被包含
新插入的元素必须得是书中独特的元素
树中所有的键必须以排序顺序保存",BTreeMap,,
../../refs/rust/library/alloc/src/collections/btree/map.rs,CursorMutKey,3234,3264,"    pub unsafe fn insert_before_unchecked(&mut self, key: K, value: V) {
        let edge = match self.current.take() {
            None => {
                // SAFETY: We have no other reference to the tree.
                match unsafe { self.root.reborrow() } {
                    root @ None => {
                        // Tree is empty, allocate a new root.
                        let mut node = NodeRef::new_leaf(self.alloc.clone());
                        // SAFETY: We don't touch the root while the handle is alive.
                        let handle = unsafe { node.borrow_mut().push_with_handle(key, value) };
                        *root = Some(node.forget_type());
                        *self.length += 1;
                        self.current = Some(handle.right_edge());
                        return;
                    }
                    Some(root) => root.borrow_mut().last_leaf_edge(),
                }
            }
            Some(current) => current,
        };

        let handle = edge.insert_recursing(key, value, self.alloc.clone(), |ins| {
            drop(ins.left);
            // SAFETY: The handle to the newly inserted value is always on a
            // leaf node, so adding a new root node doesn't invalidate it.
            let root = unsafe { self.root.reborrow().as_mut().unwrap() };
            root.push_internal_level(self.alloc.clone()).push(ins.kv.0, ins.kv.1, ins.right)
        });
        self.current = Some(handle.right_edge());
        *self.length += 1;
    }
","pub fn insert_before(&mut self, key: K, value: V) -> Result<(), UnorderedKeyError> {
        if let Some((prev, _)) = self.peek_prev() {
            if &key <= prev {
                return Err(UnorderedKeyError {});
            }
        }
        if let Some((next, _)) = self.peek_next() {
            if &key >= next {
                return Err(UnorderedKeyError {});
            }
        }
        unsafe {
            self.insert_before_unchecked(key, value);
        }
        Ok(())
    }","必须保证BTreeMap不变量被包含
新插入的元素必须得是书中独特的元素
树中所有的键必须以排序顺序保存",BTreeMap,,
../../refs/rust/library/alloc/src/collections/btree/map.rs,CursorMut,3396,3398,"    pub unsafe fn insert_after_unchecked(&mut self, key: K, value: V) {
        unsafe { self.inner.insert_after_unchecked(key, value) }
    }
","    pub fn insert_after(&mut self, key: K, value: V) -> Result<(), UnorderedKeyError> {
        self.inner.insert_after(key, value)
    }",,BTreeMap,,
../../refs/rust/library/alloc/src/collections/btree/map.rs,btreeMap,3414,3416,"    pub unsafe fn insert_before_unchecked(&mut self, key: K, value: V) {
        unsafe { self.inner.insert_before_unchecked(key, value) }
    }
","pub fn insert_before(&mut self, key: K, value: V) -> Result<(), UnorderedKeyError> {
        self.inner.insert_before(key, value)
    }",,BTreeMap,,
../../refs/rust/library/alloc/src/collections/btree/set.rs,CursoeMut,2353,2355,"    pub unsafe fn insert_after_unchecked(&mut self, value: T) {
        unsafe { self.inner.insert_after_unchecked(value, SetValZST) }
    }
","pub fn insert_after(&mut self, value: T) -> Result<(), UnorderedKeyError> {
        self.inner.insert_after(value, SetValZST)
    }",BTreeSet不变量必须被保持,BTreeMap,,
../../refs/rust/library/alloc/src/collections/btree/set.rs,null,2371,2373,"    pub unsafe fn insert_before_unchecked(&mut self, value: T) {
        unsafe { self.inner.insert_before_unchecked(value, SetValZST) }
    }
",同上,同上,BTreeMap,,
../../refs/rust/library/alloc/src/collections/btree/set.rs,null,2439,2441,"    pub unsafe fn insert_after_unchecked(&mut self, value: T) {
        unsafe { self.inner.insert_after_unchecked(value, SetValZST) }
    }
",同上,同上,BTreeMap,,
../../refs/rust/library/alloc/src/collections/btree/set.rs,null,2457,2459,"    pub unsafe fn insert_before_unchecked(&mut self, value: T) {
        unsafe { self.inner.insert_before_unchecked(value, SetValZST) }
    }
",同上,同上,BTreeMap,,
../../refs/rust/library/alloc/src/ffi/c_str.rs,Cstring,335,338,"    pub unsafe fn from_vec_unchecked(v: Vec<u8>) -> Self {
        debug_assert!(memchr::memchr(0, &v).is_none());
        unsafe { Self::_from_vec_unchecked(v) }
    }
","pub fn new<T: Into<Vec<u8>>>(t: T) -> Result<CString, NulError>",The caller has to promise that the input don’t have any interior.,Cstring,exposed,
../../refs/rust/library/alloc/src/ffi/c_str.rs,CString,625,628,"    pub unsafe fn from_vec_with_nul_unchecked(v: Vec<u8>) -> Self {
        debug_assert!(memchr::memchr(0, &v).unwrap() + 1 == v.len());
        unsafe { Self::_from_vec_with_nul_unchecked(v) }
    }
","pub fn from_vec_with_nul(v: Vec<u8>) -> Result<Self, FromVecWithNulError> {
        let nul_pos = memchr::memchr(0, &v);
        match nul_pos {
            Some(nul_pos) if nul_pos + 1 == v.len() => {
                // SAFETY: We know there is only one nul byte, at the end
                // of the vec.
                Ok(unsafe { Self::_from_vec_with_nul_unchecked(v) })
            }
            Some(nul_pos) => Err(FromVecWithNulError {
                error_kind: FromBytesWithNulErrorKind::InteriorNul(nul_pos),
                bytes: v,
            }),
            None => Err(FromVecWithNulError {
                error_kind: FromBytesWithNulErrorKind::NotNulTerminated,
                bytes: v,
            }),
        }
    }",The caller has to promise the input Vec must have only one nul as its end without any other nul and it cannot be empty.,CString,exposed,
../../refs/rust/library/alloc/src/rc.rs,"Rc<T:?Sized, A:Allocator>",1811,1815,"    pub unsafe fn get_mut_unchecked(this: &mut Self) -> &mut T {
        // We are careful to *not* create a reference covering the ""count"" fields, as
        // this would conflict with accesses to the reference counts (e.g. by `Weak`).
        unsafe { &mut (*this.ptr.as_ptr()).value }
    }
","pub fn get_mut(this: &mut Self) -> Option<&mut T> {
        if Rc::is_unique(this) { unsafe { Some(Rc::get_mut_unchecked(this)) } } else { None }
    }","/// If any other `Rc` or [`Weak`] pointers to the same allocation exist, then
    /// they must not be dereferenced or have active borrows for the duration
    /// of the returned borrow, and their inner type must be exactly the same as the
    /// inner type of this Rc (including lifetimes). This is trivially the case if no
    /// such pointers exist, for example immediately after `Rc::new`.",complex,exposed,
../../refs/rust/library/alloc/src/rc.rs,"Rc<T: dyn Any, A: Allocator>",2044,2049,"    pub unsafe fn downcast_unchecked<T: Any>(self) -> Rc<T, A> {
        unsafe {
            let (ptr, alloc) = Rc::into_inner_with_allocator(self);
            Rc::from_inner_in(ptr.cast(), alloc)
        }
    }
","pub fn downcast<T: Any>(self) -> Result<Rc<T, A>, Self> {
        if (*self).is::<T>() {
            unsafe {
                let (ptr, alloc) = Rc::into_inner_with_allocator(self);
                Ok(Rc::from_inner_in(ptr.cast(), alloc))
            }
        } else {
            Err(self)
        }
    }",The caller has to promise that the type T is the right T.,type,exposed,
../../refs/rust/library/alloc/src/str.rs,str,617,619,"pub unsafe fn from_boxed_utf8_unchecked(v: Box<[u8]>) -> Box<str> {
    unsafe { Box::from_raw(Box::into_raw(v) as *mut str) }
}
",Not found,None,unexposed,unexposed,
../../refs/rust/library/alloc/src/string.rs,String,1027,1029,"    pub unsafe fn from_utf8_unchecked(bytes: Vec<u8>) -> String {
        String { vec: bytes }
    }
","pub fn from_utf8(vec: Vec<u8>) -> Result<String, FromUtf8Error> {
        match str::from_utf8(&vec) {
            Ok(..) => Ok(String { vec }),
            Err(e) => Err(FromUtf8Error { bytes: vec, error: e }),
        }
    }",The user has to promise the bytes are valid UTF-8.,String,exposed,
../../refs/rust/library/alloc/src/sync.rs,"Arc<T:?Sized,A:Allocator>",2523,2527,"    pub unsafe fn get_mut_unchecked(this: &mut Self) -> &mut T {
        // We are careful to *not* create a reference covering the ""count"" fields, as
        // this would alias with concurrent access to the reference counts (e.g. by `Weak`).
        unsafe { &mut (*this.ptr.as_ptr()).data }
    }
","pub fn get_mut(this: &mut Self) -> Option<&mut T> {
        if this.is_unique() {
            // This unsafety is ok because we're guaranteed that the pointer
            // returned is the *only* pointer that will ever be returned to T. Our
            // reference count is guaranteed to be 1 at this point, and we required
            // the Arc itself to be `mut`, so we're returning the only possible
            // reference to the inner data.
            unsafe { Some(Arc::get_mut_unchecked(this)) }
        } else {
            None
        }
    }","/// If any other `Arc` or [`Weak`] pointers to the same allocation exist, then
    /// they must not be dereferenced or have active borrows for the duration
    /// of the returned borrow, and their inner type must be exactly the same as the
    /// inner type of this Rc (including lifetimes). This is trivially the case if no
    /// such pointers exist, for example immediately after `Arc::new`.",complex,exposed,
../../refs/rust/library/alloc/src/sync.rs,"Arc<T: dyn Any + Send +  Sync, A: Allocator>",2701,2709,"pub unsafe fn downcast_unchecked<T>(self) -> Arc<T, A>
    where
        T: Any + Send + Sync,
    {
        unsafe {
            let (ptr, alloc) = Arc::into_inner_with_allocator(self);
            Arc::from_inner_in(ptr.cast(), alloc)
        }
    }","pub fn downcast<T>(self) -> Result<Arc<T, A>, Self>
    where
        T: Any + Send + Sync,
    {
        if (*self).is::<T>() {
            unsafe {
                let (ptr, alloc) = Arc::into_inner_with_allocator(self);
                Ok(Arc::from_inner_in(ptr.cast(), alloc))
            }
        } else {
            Err(self)
        }
    }",The caller has to promise that the type T is the right T.,type,exposed,
../../refs/rust/library/core/src/alloc/layout.rs,std::alloc::Layout,129,141,"    pub const unsafe fn from_size_align_unchecked(size: usize, align: usize) -> Self {
        assert_unsafe_precondition!(
            check_library_ub,
            ""Layout::from_size_align_unchecked requires that align is a power of 2 \
            and the rounded-up allocation size does not exceed isize::MAX"",
            (
                size: usize = size,
                align: usize = align,
            ) => Layout::is_size_align_valid(size, align)
        );
        // SAFETY: the caller is required to uphold the preconditions.
        unsafe { Layout { size, align: mem::transmute(align) } }
    }
","
pub const fn from_size_align(size: usize, align: usize) -> Result<Self, LayoutError> {
        if Layout::is_size_align_valid(size, align) {
            // SAFETY: Layout::is_size_align_valid checks the preconditions for this call.
            unsafe { Ok(Layout { size, align: mem::transmute(align) }) }
        } else {
            Err(LayoutError)
        }
    }
",Caller has to promise the 'align' is a power of 2 and the 'size' does not exceed MAX.,index,exposed,
../../refs/rust/library/core/src/any.rs,Trait: dyn Any,294,298,"    pub unsafe fn downcast_ref_unchecked<T: Any>(&self) -> &T {
        debug_assert!(self.is::<T>());
        // SAFETY: caller guarantees that T is the correct type
        unsafe { &*(self as *const dyn Any as *const T) }
    }
","pub fn downcast_ref<T: Any>(&self) -> Option<&T> {
        if self.is::<T>() {
            // SAFETY: just checked whether we are pointing to the correct type, and we can rely on
            // that check for memory safety because we have implemented Any for all types; no other
            // impls can exist as they would conflict with our impl.
            unsafe { Some(self.downcast_ref_unchecked()) }
        } else {
            None
        }
    }",The caller has to promise that the type T is the right T.,type,exposed,
../../refs/rust/library/core/src/any.rs,Trait: dyn Any,324,328,"    pub unsafe fn downcast_mut_unchecked<T: Any>(&mut self) -> &mut T {
        debug_assert!(self.is::<T>());
        // SAFETY: caller guarantees that T is the correct type
        unsafe { &mut *(self as *mut dyn Any as *mut T) }
    }
","pub fn downcast_mut<T: Any>(&mut self) -> Option<&mut T> {
        if self.is::<T>() {
            // SAFETY: just checked whether we are pointing to the correct type, and we can rely on
            // that check for memory safety because we have implemented Any for all types; no other
            // impls can exist as they would conflict with our impl.
            unsafe { Some(self.downcast_mut_unchecked()) }
        } else {
            None
        }
    }",The caller has to promise that the type T is the right T.,type,exposed,
../../refs/rust/library/core/src/any.rs,Trait: dyn Any + Send,430,433,"    pub unsafe fn downcast_ref_unchecked<T: Any>(&self) -> &T {
        // SAFETY: guaranteed by caller
        unsafe { <dyn Any>::downcast_ref_unchecked::<T>(self) }
    }
","pub fn downcast_ref<T: Any>(&self) -> Option<&T> {
        <dyn Any>::downcast_ref::<T>(self)
    }",The caller has to promise that the type T is the right T.,type,exposed,
../../refs/rust/library/core/src/any.rs,Trait: dyn Any + Send,459,462,"    pub unsafe fn downcast_mut_unchecked<T: Any>(&mut self) -> &mut T {
        // SAFETY: guaranteed by caller
        unsafe { <dyn Any>::downcast_mut_unchecked::<T>(self) }
    }
","pub fn downcast_mut<T: Any>(&mut self) -> Option<&mut T> {
        <dyn Any>::downcast_mut::<T>(self)
    }",The caller has to promise that the type T is the right T.,type,exposed,
../../refs/rust/library/core/src/any.rs,Trait: dyn Any + Send + Sync,563,566,"    pub unsafe fn downcast_ref_unchecked<T: Any>(&self) -> &T {
        // SAFETY: guaranteed by caller
        unsafe { <dyn Any>::downcast_ref_unchecked::<T>(self) }
    }
","pub fn downcast_ref<T: Any>(&self) -> Option<&T> {
        <dyn Any>::downcast_ref::<T>(self)
    }",The caller has to promise that the type T is the right T.,type,exposed,
../../refs/rust/library/core/src/any.rs,Trait: dyn Any + Send + Sync,591,594,"    pub unsafe fn downcast_mut_unchecked<T: Any>(&mut self) -> &mut T {
        // SAFETY: guaranteed by caller
        unsafe { <dyn Any>::downcast_mut_unchecked::<T>(self) }
    }
","pub fn downcast_mut<T: Any>(&mut self) -> Option<&mut T> {
        <dyn Any>::downcast_mut::<T>(self)
    }",The caller has to promise that the type T is the right T.,type,exposed,
../../refs/rust/library/core/src/array/ascii.rs,[u8;N],39,44,"    pub const unsafe fn as_ascii_unchecked(&self) -> &[ascii::Char; N] {
        let byte_ptr: *const [u8; N] = self;
        let ascii_ptr = byte_ptr as *const [ascii::Char; N];
        // SAFETY: The caller promised all the bytes are ASCII
        unsafe { &*ascii_ptr }
    }
","
pub const fn as_ascii(&self) -> Option<&[ascii::Char; N]> {
        if self.is_ascii() {
            // SAFETY: Just checked that it's ASCII
            Some(unsafe { self.as_ascii_unchecked() })
        } else {
            None
        }
    }
",Caller has to promise all the bytes in [u8] are ASCII.,index,exposed,
../../refs/rust/library/core/src/array/iter.rs,"IntoIter<T,N>",139,146,"
pub const unsafe fn new_unchecked(
        buffer: [MaybeUninit<T>; N],
        initialized: Range<usize>,
    ) -> Self {
        // SAFETY: one of our safety conditions is that the range is canonical.
        let alive = unsafe { IndexRange::new_unchecked(initialized.start, initialized.end) };
        Self { data: buffer, alive }
    }
",无直接对应安全函数,需要确定参数的范围是规范的,complex,,
../../refs/rust/library/core/src/ascii/ascii_char.rs,AsciiChar,469,472,"    pub const unsafe fn from_u8_unchecked(b: u8) -> Self {
        // SAFETY: Our safety precondition is that `b` is in-range.
        unsafe { transmute(b) }
    }
","pub const fn from_u8(b: u8) -> Option<Self> {
        if b <= 127 {
            // SAFETY: Just checked that `b` is in-range
            Some(unsafe { Self::from_u8_unchecked(b) })
        } else {
            None
        }
    }",Caller has to promise the 'b' is in ASCII.,index,unexposed,
../../refs/rust/library/core/src/ascii/ascii_char.rs,AsciiChar,506,520,"    pub const unsafe fn digit_unchecked(d: u8) -> Self {
        assert_unsafe_precondition!(
            check_language_ub,
            ""`ascii::Char::digit_unchecked` input cannot exceed 9."",
            (d: u8 = d) => d < 10
        );

        // SAFETY: `'0'` through `'9'` are U+00030 through U+0039,
        // so because `d` must be 64 or less the addition can return at most
        // 112 (0x70), which doesn't overflow and is within the ASCII range.
        unsafe {
            let byte = b'0'.unchecked_add(d);
            Self::from_u8_unchecked(byte)
        }
    }
","pub const fn digit(d: u8) -> Option<Self> {
        if d < 10 {
            // SAFETY: Just checked it's in-range.
            Some(unsafe { Self::digit_unchecked(d) })
        } else {
            None
        }
    }",Caller has to promise the 'd' in 0-9.,index,unexposed,
../../refs/rust/library/core/src/cell.rs,UnsafeCell<T:?Sized>,2284,2287,"    pub const unsafe fn as_ref_unchecked(&self) -> &T {
        // SAFETY: pointer comes from `&self` so naturally satisfies ptr-to-ref invariants.
        unsafe { self.get().as_ref_unchecked() }
    }
","无直接对应的unsafe版本, 与RefCell有关",null,complex,,
../../refs/rust/library/core/src/cell.rs,UnsafeCell<T:?Sized>,2312,2315,"    pub const unsafe fn as_mut_unchecked(&self) -> &mut T {
        // SAFETY: pointer comes from `&self` so naturally satisfies ptr-to-ref invariants.
        unsafe { self.get().as_mut_unchecked() }
    }
","无直接对应的unsafe版本, 与RefMut有关",null,complex,,
../../refs/rust/library/core/src/char/methods.rs,char,236,239,"    pub const unsafe fn from_u32_unchecked(i: u32) -> char {
        // SAFETY: the safety contract must be upheld by the caller.
        unsafe { super::convert::from_u32_unchecked(i) }
    }
","
   pub const fn from_u32(i: u32) -> Option<char> {
        super::convert::from_u32(i)
    }
",Caller has to promise the 'i' is a valid 'char' values.,index,unexposed,
../../refs/rust/library/core/src/char/mod.rs,char,141,144,"pub const unsafe fn from_u32_unchecked(i: u32) -> char {
    // SAFETY: the safety contract must be upheld by the caller.
    unsafe { self::convert::from_u32_unchecked(i) }
}
","pub const fn from_u32(i: u32) -> Option<char> {
    self::convert::from_u32(i)
}",Caller has to promise the 'i' is a valid 'char' values.,index,exposed,
../../refs/rust/library/core/src/ffi/c_str.rs,Cstr,396,426,"    pub const unsafe fn from_bytes_with_nul_unchecked(bytes: &[u8]) -> &CStr {
        const_eval_select!(
            @capture { bytes: &[u8] } -> &CStr:
            if const {
                // Saturating so that an empty slice panics in the assert with a good
                // message, not here due to underflow.
                let mut i = bytes.len().saturating_sub(1);
                assert!(!bytes.is_empty() && bytes[i] == 0, ""input was not nul-terminated"");

                // Ending nul byte exists, skip to the rest.
                while i != 0 {
                    i -= 1;
                    let byte = bytes[i];
                    assert!(byte != 0, ""input contained interior nul"");
                }

                // SAFETY: See runtime cast comment below.
                unsafe { &*(bytes as *const [u8] as *const CStr) }
            } else {
                // Chance at catching some UB at runtime with debug builds.
                debug_assert!(!bytes.is_empty() && bytes[bytes.len() - 1] == 0);

                // SAFETY: Casting to CStr is safe because its internal representation
                // is a [u8] too (safe only inside std).
                // Dereferencing the obtained pointer is safe because it comes from a
                // reference. Making a reference is then safe because its lifetime
                // is bound by the lifetime of the given `bytes`.
                unsafe { &*(bytes as *const [u8] as *const CStr) }
            }
        )
    }
","pub const fn from_bytes_with_nul(bytes: &[u8]) -> Result<&Self, FromBytesWithNulError> {
        let nul_pos = memchr::memchr(0, bytes);
        match nul_pos {
            Some(nul_pos) if nul_pos + 1 == bytes.len() => {
                // SAFETY: We know there is only one nul byte, at the end
                // of the byte slice.
                Ok(unsafe { Self::from_bytes_with_nul_unchecked(bytes) })
            }
            Some(position) => Err(FromBytesWithNulError::InteriorNul { position }),
            None => Err(FromBytesWithNulError::NotNulTerminated),
        }
    }",The caller has to promise the slice is end with nul and don’t contain any interrior nul bytes,Cstring/Nul,exposed,
../../refs/rust/library/core/src/hint.rs,core::hint,101,110,"pub const unsafe fn unreachable_unchecked() -> ! {
    ub_checks::assert_unsafe_precondition!(
        check_language_ub,
        ""hint::unreachable_unchecked must never be reached"",
        () => false
    );
    // SAFETY: the safety contract for `intrinsics::unreachable` must
    // be upheld by the caller.
    unsafe { intrinsics::unreachable() }
}
","pub const unsafe fn unreachable() -> !; ---> will UB
 or
unreachable!() ---> will panic","Rarely used, it's safe only when this code branch will never be reached. Otherwise, it will lead to UB.",intrinsic,unexposed,
../../refs/rust/library/core/src/hint.rs,core::hint,200,210,"pub const unsafe fn assert_unchecked(cond: bool) {
    // SAFETY: The caller promised `cond` is true.
    unsafe {
        ub_checks::assert_unsafe_precondition!(
            check_language_ub,
            ""hint::assert_unchecked must never be called when the condition is false"",
            (cond: bool = cond) => cond,
        );
        crate::intrinsics::assume(cond);
    }
}
","pub const unsafe fn assume(b: bool) {
    if !b {
        // SAFETY: the caller must guarantee the argument is never `false`
        unsafe { unreachable() }
    }
}
or
assert!()","Rarely used, it is equal to the cond is always true. 
It invokes unreachable() inside and leads to UB if reached. ",intrinsic,unexposed,
../../refs/rust/library/core/src/intrinsics/mod.rs,core::intrinsic,1700,1700,"pub const unsafe fn transmute_unchecked<Src, Dst>(src: Src) -> Dst;","pub const unsafe fn transmute<Src, Dst>(src: Src) -> Dst;","Fundamentally unsafe, handle separately.",intrinsic,unexposed,
../../refs/rust/library/core/src/intrinsics/mod.rs,intrinsic,2474,0,"pub unsafe fn float_to_int_unchecked<Float: Copy, Int: Copy>(value: Float) -> Int;",No directly corresponding safe function,"Not used directly, see library/core/num/fxx.rs for details.",type,unexposed,
../../refs/rust/library/core/src/intrinsics/mod.rs,core::intrinsic,2802,2802,"pub const unsafe fn unchecked_div<T: Copy>(x: T, y: T) -> T;",No directly corresponding safe function,"Not used directly, see library/core/src/num for details",intrinsic,unexposed,
../../refs/rust/library/core/src/intrinsics/mod.rs,core::intrinsic,2812,2812,"pub const unsafe fn unchecked_rem<T: Copy>(x: T, y: T) -> T;",No directly corresponding safe function,"Not used directly, see library/core/src/num for details",intrinsic,unexposed,
../../refs/rust/library/core/src/intrinsics/mod.rs,core::intrinsic,2823,2823,"pub const unsafe fn unchecked_shl<T: Copy, U: Copy>(x: T, y: U) -> T;",No directly corresponding safe function,"Not used directly, see library/core/src/num for details",intrinsic,unexposed,
../../refs/rust/library/core/src/intrinsics/mod.rs,core::intrinsic,2833,2833,"pub const unsafe fn unchecked_shr<T: Copy, U: Copy>(x: T, y: U) -> T;",No directly corresponding safe function,"Not used directly, see library/core/src/num for details",intrinsic,unexposed,
../../refs/rust/library/core/src/intrinsics/mod.rs,core::intrinsic,2843,2843,"pub const unsafe fn unchecked_add<T: Copy>(x: T, y: T) -> T;",No directly corresponding safe function,"Not used directly, see library/core/src/num for details",intrinsic,unexposed,
../../refs/rust/library/core/src/intrinsics/mod.rs,core::intrinsic,2853,2853,"pub const unsafe fn unchecked_sub<T: Copy>(x: T, y: T) -> T;",No directly corresponding safe function,"Not used directly, see library/core/src/num for details",intrinsic,unexposed,
../../refs/rust/library/core/src/intrinsics/mod.rs,core::intrinsic,2863,2863,"pub const unsafe fn unchecked_mul<T: Copy>(x: T, y: T) -> T;",No directly corresponding safe function,"Not used directly, see library/core/src/num for details",intrinsic,unexposed,
../../refs/rust/library/core/src/io/borrowed_buf.rs,BorrowedCursor<'a>,302,306,"    pub unsafe fn advance_unchecked(&mut self, n: usize) -> &mut Self {
        self.buf.filled += n;
        self.buf.init = cmp::max(self.buf.init, self.buf.filled);
        self
    }
","pub fn advance(&mut self, n: usize) -> &mut Self {
        let filled = self.buf.filled.strict_add(n);
        assert!(filled <= self.buf.init);

        self.buf.filled = filled;
        self
    }","如果没有n个初始化, 则panic",complex,,
../../refs/rust/library/core/src/num/f128.rs,f128,872,0,"pub unsafe fn to_int_unchecked<Int>(self) -> Int
    where
        Self: FloatToInt<Int>,
    {
        // SAFETY: the caller must uphold the safety contract for
        // `FloatToInt::to_int_unchecked`.
        unsafe { FloatToInt::<Int>::to_int_unchecked(self) }
    }","Not found, maybe some common transmute function?","The caller has to promise the value not be NaN, infinite and be representable in the return type Int.",float,exposed,
../../refs/rust/library/core/src/num/f16.rs,f16,858,0,"pub unsafe fn to_int_unchecked<Int>(self) -> Int
    where
        Self: FloatToInt<Int>,
    {
        // SAFETY: the caller must uphold the safety contract for
        // `FloatToInt::to_int_unchecked`.
        unsafe { FloatToInt::<Int>::to_int_unchecked(self) }
    }","Not found, maybe some common transmute function?","The caller has to promise the value not be NaN, infinite and be representable in the return type Int.",float,exposed,
../../refs/rust/library/core/src/num/f32.rs,f32,1062,0," pub unsafe fn to_int_unchecked<Int>(self) -> Int
    where
        Self: FloatToInt<Int>,
    {
        // SAFETY: the caller must uphold the safety contract for
        // `FloatToInt::to_int_unchecked`.
        unsafe { FloatToInt::<Int>::to_int_unchecked(self) }
    }","Not found, maybe some common transmute function?","The caller has to promise the value not be NaN, infinite and be representable in the return type Int.",float,exposed,
../../refs/rust/library/core/src/num/f64.rs,f64,1063,0,"pub unsafe fn to_int_unchecked<Int>(self) -> Int
    where
        Self: FloatToInt<Int>,
    {
        // SAFETY: the caller must uphold the safety contract for
        // `FloatToInt::to_int_unchecked`.
        unsafe { FloatToInt::<Int>::to_int_unchecked(self) }
    }","Not found, maybe some common transmute function?","The caller has to promise the value not be NaN, infinite and be representable in the return type Int.",float,exposed,
../../refs/rust/library/core/src/num/int_macros.rs,num,559,573,"        pub const unsafe fn unchecked_add(self, rhs: Self) -> Self {
            assert_unsafe_precondition!(
                check_language_ub,
                concat!(stringify!($SelfT), ""::unchecked_add cannot overflow""),
                (
                    lhs: $SelfT = self,
                    rhs: $SelfT = rhs,
                ) => !lhs.overflowing_add(rhs).1,
            );

            // SAFETY: this is guaranteed to be safe by the caller.
            unsafe {
                intrinsics::unchecked_add(self, rhs)
            }
        }
","pub const fn checked_add(self, rhs: Self) -> Option<Self> {
            let (a, b) = self.overflowing_add(rhs);
            if intrinsics::unlikely(b) { None } else { Some(a) }
        }",The  caller has to promise there is no overflow.,overflow,exposed,
../../refs/rust/library/core/src/num/int_macros.rs,num,709,723,"        pub const unsafe fn unchecked_sub(self, rhs: Self) -> Self {
            assert_unsafe_precondition!(
                check_language_ub,
                concat!(stringify!($SelfT), ""::unchecked_sub cannot overflow""),
                (
                    lhs: $SelfT = self,
                    rhs: $SelfT = rhs,
                ) => !lhs.overflowing_sub(rhs).1,
            );

            // SAFETY: this is guaranteed to be safe by the caller.
            unsafe {
                intrinsics::unchecked_sub(self, rhs)
            }
        }
","pub const fn checked_sub(self, rhs: Self) -> Option<Self> {
            let (a, b) = self.overflowing_sub(rhs);
            if intrinsics::unlikely(b) { None } else { Some(a) }
        }",The caller has to promise there is no overflow.,overflow/nonzero,exposed,
../../refs/rust/library/core/src/num/int_macros.rs,num,859,873,"        pub const unsafe fn unchecked_mul(self, rhs: Self) -> Self {
            assert_unsafe_precondition!(
                check_language_ub,
                concat!(stringify!($SelfT), ""::unchecked_mul cannot overflow""),
                (
                    lhs: $SelfT = self,
                    rhs: $SelfT = rhs,
                ) => !lhs.overflowing_mul(rhs).1,
            );

            // SAFETY: this is guaranteed to be safe by the caller.
            unsafe {
                intrinsics::unchecked_mul(self, rhs)
            }
        }
","pub const fn checked_mul(self, rhs: Self) -> Option<Self> {
            let (a, b) = self.overflowing_mul(rhs);
            if intrinsics::unlikely(b) { None } else { Some(a) }
        }",The caller has to promise there is no overflow.,overflow/nonzero,exposed,
../../refs/rust/library/core/src/num/int_macros.rs,num,1203,1216,"        pub const unsafe fn unchecked_neg(self) -> Self {
            assert_unsafe_precondition!(
                check_language_ub,
                concat!(stringify!($SelfT), ""::unchecked_neg cannot overflow""),
                (
                    lhs: $SelfT = self,
                ) => !lhs.overflowing_neg().1,
            );

            // SAFETY: this is guaranteed to be safe by the caller.
            unsafe {
                intrinsics::unchecked_sub(0, self)
            }
        }
","pub const fn checked_neg(self) -> Option<Self> {
            let (a, b) = self.overflowing_neg();
            if intrinsics::unlikely(b) { None } else { Some(a) }
        }",The caller has to promise there is no overflow.,overflow/nonzero,exposed,
../../refs/rust/library/core/src/num/int_macros.rs,num,1331,1344,"        pub const unsafe fn unchecked_shl(self, rhs: u32) -> Self {
            assert_unsafe_precondition!(
                check_language_ub,
                concat!(stringify!($SelfT), ""::unchecked_shl cannot overflow""),
                (
                    rhs: u32 = rhs,
                ) => rhs < <$ActualT>::BITS,
            );

            // SAFETY: this is guaranteed to be safe by the caller.
            unsafe {
                intrinsics::unchecked_shl(self, rhs)
            }
        }
","pub const fn checked_shl(self, rhs: u32) -> Option<Self> {
            // Not using overflowing_shl as that's a wrapping shift
            if rhs < Self::BITS {
                // SAFETY: just checked the RHS is in-range
                Some(unsafe { self.unchecked_shl(rhs) })
            } else {
                None
            }
        }",The caller has to promise there is no overflow.,overflow/nonzero,exposed,
../../refs/rust/library/core/src/num/int_macros.rs,num,1452,1465,"        pub const unsafe fn unchecked_shr(self, rhs: u32) -> Self {
            assert_unsafe_precondition!(
                check_language_ub,
                concat!(stringify!($SelfT), ""::unchecked_shr cannot overflow""),
                (
                    rhs: u32 = rhs,
                ) => rhs < <$ActualT>::BITS,
            );

            // SAFETY: this is guaranteed to be safe by the caller.
            unsafe {
                intrinsics::unchecked_shr(self, rhs)
            }
        }
","pub const fn checked_shr(self, rhs: u32) -> Option<Self> {
            // Not using overflowing_shr as that's a wrapping shift
            if rhs < Self::BITS {
                // SAFETY: just checked the RHS is in-range
                Some(unsafe { self.unchecked_shr(rhs) })
            } else {
                None
            }
        }",The caller has to promise there is no overflow.,overflow/nonzero,exposed,
../../refs/rust/library/core/src/num/niche_types.rs,num,52,55,"            pub const unsafe fn new_unchecked(val: $int) -> Self {
                // SAFETY: Caller promised that `val` is non-zero.
                unsafe { $name(val) }
            }
","pub const fn new(val: $int) -> Option<Self> {
                if (val as $uint) >= ($low as $uint) && (val as $uint) <= ($high as $uint) {
                    // SAFETY: just checked the inclusive range
                    Some(unsafe { $name(val) })
                } else {
                    None
                }
            }","This is a group of many similar structs constructed with integer. However, all of them are required the value is non-zero.",nonzero,exposed,
../../refs/rust/library/core/src/num/nonzero.rs,Nonzero<T>,391,406,"    pub const unsafe fn new_unchecked(n: T) -> Self {
        match Self::new(n) {
            Some(n) => n,
            None => {
                // SAFETY: The caller guarantees that `n` is non-zero, so this is unreachable.
                unsafe {
                    ub_checks::assert_unsafe_precondition!(
                        check_language_ub,
                        ""NonZero::new_unchecked requires the argument to be non-zero"",
                        () => false,
                    );
                    intrinsics::unreachable()
                }
            }
        }
    }
","pub const fn new(n: T) -> Option<Self> {
        // SAFETY: Memory layout optimization guarantees that `Option<NonZero<T>>` has
        //         the same layout and size as `T`, with `0` representing `None`.
        unsafe { intrinsics::transmute_unchecked(n) }
    }",The caller has to promise that the argument has to be non-zero.,nonzero,exposed,
../../refs/rust/library/core/src/num/nonzero.rs,NonZero<T>,431,446,"    pub unsafe fn from_mut_unchecked(n: &mut T) -> &mut Self {
        match Self::from_mut(n) {
            Some(n) => n,
            None => {
                // SAFETY: The caller guarantees that `n` references a value that is non-zero, so this is unreachable.
                unsafe {
                    ub_checks::assert_unsafe_precondition!(
                        check_library_ub,
                        ""NonZero::from_mut_unchecked requires the argument to dereference as non-zero"",
                        () => false,
                    );
                    intrinsics::unreachable()
                }
            }
        }
    }
","pub fn from_mut(n: &mut T) -> Option<&mut Self> {
        // SAFETY: Memory layout optimization guarantees that `Option<NonZero<T>>` has
        //         the same layout and size as `T`, with `0` representing `None`.
        let opt_n = unsafe { &mut *(ptr::from_mut(n).cast::<Option<Self>>()) };

        opt_n.as_mut()
    }",The caller has to promise the refrence value is non-zero.,nonzero,exposed,
../../refs/rust/library/core/src/num/nonzero.rs,nonzero,1089,1092,"            pub const unsafe fn unchecked_mul(self, other: Self) -> Self {
                // SAFETY: The caller ensures there is no overflow.
                unsafe { Self::new_unchecked(self.get().unchecked_mul(other.get())) }
            }
","pub const fn checked_mul(self, other: Self) -> Option<Self> {
                if let Some(result) = self.get().checked_mul(other.get()) {
                    // SAFETY:
                    // - `checked_mul` returns `None` on overflow
                    // - `self` and `other` are non-zero
                    // - the only way to get zero from a multiplication without overflow is for one
                    //   of the sides to be zero
                    //
                    // So the result cannot be zero.
                    Some(unsafe { Self::new_unchecked(result) })
                } else {
                    None
                }
            }","The caller has to promise there is  no overflow.
This is for both integer and unsigned integer.",overflow/nonzero,exposed,
../../refs/rust/library/core/src/num/nonzero.rs,nonzero,1491,1494,"        pub const unsafe fn unchecked_add(self, other: $Int) -> Self {
            // SAFETY: The caller ensures there is no overflow.
            unsafe { Self::new_unchecked(self.get().unchecked_add(other)) }
        }
","pub const fn checked_add(self, other: $Int) -> Option<Self> {
            if let Some(result) = self.get().checked_add(other) {
                // SAFETY:
                // - `checked_add` returns `None` on overflow
                // - `self` is non-zero
                // - the only way to get zero from an addition without overflow is for both
                //   sides to be zero
                //
                // So the result cannot be zero.
                Some(unsafe { Self::new_unchecked(result) })
            } else {
                None
            }
        }","The caller has to promise there is  no overflow.
This is for only unsigned interger.",overflow/nonzero,exposed,
../../refs/rust/library/core/src/num/uint_macros.rs,num,605,619,"        pub const unsafe fn unchecked_add(self, rhs: Self) -> Self {
            assert_unsafe_precondition!(
                check_language_ub,
                concat!(stringify!($SelfT), ""::unchecked_add cannot overflow""),
                (
                    lhs: $SelfT = self,
                    rhs: $SelfT = rhs,
                ) => !lhs.overflowing_add(rhs).1,
            );

            // SAFETY: this is guaranteed to be safe by the caller.
            unsafe {
                intrinsics::unchecked_add(self, rhs)
            }
        }
","pub const fn checked_add(self, rhs: Self) -> Option<Self> {
            // This used to use `overflowing_add`, but that means it ends up being
            // a `wrapping_add`, losing some optimization opportunities. Notably,
            // phrasing it this way helps `.checked_add(1)` optimize to a check
            // against `MAX` and a `add nuw`.
            // Per <https://github.com/rust-lang/rust/pull/124114#issuecomment-2066173305>,
            // LLVM is happy to re-form the intrinsic later if useful.

            if intrinsics::unlikely(intrinsics::add_with_overflow(self, rhs).1) {
                None
            } else {
                // SAFETY: Just checked it doesn't overflow
                Some(unsafe { intrinsics::unchecked_add(self, rhs) })
            }
        }",The caller has to promise there is no overflow.,overflow/nonzero,exposed,
../../refs/rust/library/core/src/num/uint_macros.rs,num,795,809,"        pub const unsafe fn unchecked_sub(self, rhs: Self) -> Self {
            assert_unsafe_precondition!(
                check_language_ub,
                concat!(stringify!($SelfT), ""::unchecked_sub cannot overflow""),
                (
                    lhs: $SelfT = self,
                    rhs: $SelfT = rhs,
                ) => !lhs.overflowing_sub(rhs).1,
            );

            // SAFETY: this is guaranteed to be safe by the caller.
            unsafe {
                intrinsics::unchecked_sub(self, rhs)
            }
        }
","pub const fn checked_sub(self, rhs: Self) -> Option<Self> {
            // Per PR#103299, there's no advantage to the `overflowing` intrinsic
            // for *unsigned* subtraction and we just emit the manual check anyway.
            // Thus, rather than using `overflowing_sub` that produces a wrapping
            // subtraction, check it ourself so we can use an unchecked one.

            if self < rhs {
                None
            } else {
                // SAFETY: just checked this can't overflow
                Some(unsafe { intrinsics::unchecked_sub(self, rhs) })
            }
        }",The caller has to promise there is no overflow.,overflow/nonzero,exposed,
../../refs/rust/library/core/src/num/uint_macros.rs,num,978,992,"        pub const unsafe fn unchecked_mul(self, rhs: Self) -> Self {
            assert_unsafe_precondition!(
                check_language_ub,
                concat!(stringify!($SelfT), ""::unchecked_mul cannot overflow""),
                (
                    lhs: $SelfT = self,
                    rhs: $SelfT = rhs,
                ) => !lhs.overflowing_mul(rhs).1,
            );

            // SAFETY: this is guaranteed to be safe by the caller.
            unsafe {
                intrinsics::unchecked_mul(self, rhs)
            }
        }
","pub const fn checked_mul(self, rhs: Self) -> Option<Self> {
            let (a, b) = self.overflowing_mul(rhs);
            if intrinsics::unlikely(b) { None } else { Some(a) }
        }",The caller has to promise there is no overflow.,overflow/nonzero,exposed,
../../refs/rust/library/core/src/num/uint_macros.rs,num,1265,1277,"        pub const unsafe fn unchecked_disjoint_bitor(self, other: Self) -> Self {
            assert_unsafe_precondition!(
                check_language_ub,
                concat!(stringify!($SelfT), ""::unchecked_disjoint_bitor cannot have overlapping bits""),
                (
                    lhs: $SelfT = self,
                    rhs: $SelfT = other,
                ) => (lhs & rhs) == 0,
            );

            // SAFETY: Same precondition
            unsafe { intrinsics::disjoint_bitor(self, other) }
        }
",self | other,The caller has to promise self & other == 0,complex,exposed,
../../refs/rust/library/core/src/num/uint_macros.rs,num,1592,1605,"        pub const unsafe fn unchecked_shl(self, rhs: u32) -> Self {
            assert_unsafe_precondition!(
                check_language_ub,
                concat!(stringify!($SelfT), ""::unchecked_shl cannot overflow""),
                (
                    rhs: u32 = rhs,
                ) => rhs < <$ActualT>::BITS,
            );

            // SAFETY: this is guaranteed to be safe by the caller.
            unsafe {
                intrinsics::unchecked_shl(self, rhs)
            }
        }
","pub const fn checked_shl(self, rhs: u32) -> Option<Self> {
            // Not using overflowing_shl as that's a wrapping shift
            if rhs < Self::BITS {
                // SAFETY: just checked the RHS is in-range
                Some(unsafe { self.unchecked_shl(rhs) })
            } else {
                None
            }
        }",The caller has to promise there is no overflow.,overflow/nonzero,exposed,
../../refs/rust/library/core/src/num/uint_macros.rs,num,1713,1726,"        pub const unsafe fn unchecked_shr(self, rhs: u32) -> Self {
            assert_unsafe_precondition!(
                check_language_ub,
                concat!(stringify!($SelfT), ""::unchecked_shr cannot overflow""),
                (
                    rhs: u32 = rhs,
                ) => rhs < <$ActualT>::BITS,
            );

            // SAFETY: this is guaranteed to be safe by the caller.
            unsafe {
                intrinsics::unchecked_shr(self, rhs)
            }
        }
","pub const fn checked_shr(self, rhs: u32) -> Option<Self> {
            // Not using overflowing_shr as that's a wrapping shift
            if rhs < Self::BITS {
                // SAFETY: just checked the RHS is in-range
                Some(unsafe { self.unchecked_shr(rhs) })
            } else {
                None
            }
        }",The caller has to promise there is no overflow.,overflow/nonzero,exposed,
../../refs/rust/library/core/src/option.rs,Option,1083,1089,"    pub const unsafe fn unwrap_unchecked(self) -> T {
        match self {
            Some(val) => val,
            // SAFETY: the safety contract must be upheld by the caller.
            None => unsafe { hint::unreachable_unchecked() },
        }
    }
","pub const fn unwrap(self) -> T {
        match self {
            Some(val) => val,
            None => unwrap_failed(),
        }
    }
",Caller has to promise the Option is not 'None'.,Reuslt/Option,exposed,
../../refs/rust/library/core/src/pin.rs,"Pin<&;a, T:?Sized>",1357,1359,"    pub const unsafe fn new_unchecked(pointer: Ptr) -> Pin<Ptr> {
        Pin { __pointer: pointer }
    }
","
    pub const fn new(pointer: Ptr) -> Pin<Ptr> {
        // SAFETY: the value pointed to is `Unpin`, and so has no requirements
        // around pinning.
        unsafe { Pin::new_unchecked(pointer) }
    }
",None,pin,exposed,
../../refs/rust/library/core/src/pin.rs,"Pin<&;a, T:?Sized>",1510,1512,"    pub const unsafe fn into_inner_unchecked(pin: Pin<Ptr>) -> Ptr {
        pin.__pointer
    }
","
 pub const fn into_inner(pin: Pin<Ptr>) -> Ptr {
        pin.__pointer
    }
",None,pin,exposed,
../../refs/rust/library/core/src/pin.rs,"Pin<&;a, T:?Sized>",1532,1543," pub unsafe fn map_unchecked<U, F>(self, func: F) -> Pin<&'a U>
    where
        U: ?Sized,
        F: FnOnce(&T) -> &U,
    {
        let pointer = &*self.__pointer;
        let new_pointer = func(pointer);

        // SAFETY: the safety contract for `new_unchecked` must be
        // upheld by the caller.
        unsafe { Pin::new_unchecked(new_pointer) }
    }",Not found,The caller has to promise the data will not move.,pin,exposed,
../../refs/rust/library/core/src/pin.rs,"Pin<&;a, T:?Sized>",1615,1617,"    pub const unsafe fn get_unchecked_mut(self) -> &'a mut T {
        self.__pointer
    }
","
pub const fn get_mut(self) -> &'a mut T
    where
        T: Unpin,
    {
        self.__pointer
    }
","/// This function is unsafe. You must guarantee that you will never move
/// the data out of the mutable reference you receive when you call this
/// function, so that the invariants on the `Pin` type can be upheld.",pin,exposed,
../../refs/rust/library/core/src/pin.rs,"Pin<&;a, T:?Sized>",1636,0,"pub unsafe fn map_unchecked_mut<U, F>(self, func: F) -> Pin<&'a mut U>
    where
        U: ?Sized,
        F: FnOnce(&mut T) -> &mut U,
    {
        // SAFETY: the caller is responsible for not moving the
        // value out of this reference.
        let pointer = unsafe { Pin::get_unchecked_mut(self) };
        let new_pointer = func(pointer);
        // SAFETY: as the value of `this` is guaranteed to not have
        // been moved out, this call to `new_unchecked` is safe.
        unsafe { Pin::new_unchecked(new_pointer) }
    }",Not found,The caller has to promise the data will not move.,pin,exposed,
../../refs/rust/library/core/src/ptr/alignment.rs,ptr::Alignment,76,86,"    pub const unsafe fn new_unchecked(align: usize) -> Self {
        assert_unsafe_precondition!(
            check_language_ub,
            ""Alignment::new_unchecked requires a power of two"",
            (align: usize = align) => align.is_power_of_two()
        );

        // SAFETY: By precondition, this must be a power of two, and
        // our variants encompass all possible powers of two.
        unsafe { mem::transmute::<usize, Alignment>(align) }
    }
","
pub const fn new(align: usize) -> Option<Self> {
        if align.is_power_of_two() {
            // SAFETY: Just checked it only has one bit set
            Some(unsafe { Self::new_unchecked(align) })
        } else {
            None
        }
    }
",Caller has to promise 'align' is a power of 2 and can not be zero.,index,exposed,
../../refs/rust/library/core/src/ptr/const_ptr.rs,*const T + <T+?Sized>,327,330,"    pub const unsafe fn as_ref_unchecked<'a>(self) -> &'a T {
        // SAFETY: the caller must guarantee that `self` is valid for a reference
        unsafe { &*self }
    }
","pub const unsafe fn as_ref<'a>(self) -> Option<&'a T> {
        // SAFETY: the caller must guarantee that `self` is valid
        // for a reference if it isn't null.
        if self.is_null() { None } else { unsafe { Some(&*self) } }
    }",Caller has to promise the pointer is convertible to a reference.,nullptr,exposed,
../../refs/rust/library/core/src/ptr/const_ptr.rs,*const [T],1576,0,"pub unsafe fn get_unchecked<I>(self, index: I) -> *const I::Output
    where
        I: SliceIndex<[T]>,
    {
        // SAFETY: the caller ensures that `self` is dereferenceable and `index` in-bounds.
        unsafe { index.get_unchecked(self) }
    }",Not found,The caller has to promise the self is dereferenceable and index is  in-bounds.,complex/nullptr/index,exposed,
../../refs/rust/library/core/src/ptr/mut_ptr.rs,*mut T + <T+?Sized>,319,322,"    pub const unsafe fn as_ref_unchecked<'a>(self) -> &'a T {
        // SAFETY: the caller must guarantee that `self` is valid for a reference
        unsafe { &*self }
    }
","pub const unsafe fn as_ref<'a>(self) -> Option<&'a T> {
        // SAFETY: the caller must guarantee that `self` is valid for a
        // reference if it isn't null.
        if self.is_null() { None } else { unsafe { Some(&*self) } }
    }",Caller has to promise the pointer is convertible to a reference.,nullptr,exposed,
../../refs/rust/library/core/src/ptr/mut_ptr.rs,*mut T + <T+?Sized>,681,684,"    pub const unsafe fn as_mut_unchecked<'a>(self) -> &'a mut T {
        // SAFETY: the caller must guarantee that `self` is valid for a reference
        unsafe { &mut *self }
    }
","pub const unsafe fn as_mut<'a>(self) -> Option<&'a mut T> {
        // SAFETY: the caller must guarantee that `self` is be valid for
        // a mutable reference if it isn't null.
        if self.is_null() { None } else { unsafe { Some(&mut *self) } }
    }",Caller has to promise the pointer is convertible to a reference.,nullptr,exposed,
../../refs/rust/library/core/src/ptr/mut_ptr.rs,*mut [T],1876,1886,"    pub unsafe fn split_at_mut_unchecked(self, mid: usize) -> (*mut [T], *mut [T]) {
        let len = self.len();
        let ptr = self.as_mut_ptr();

        // SAFETY: Caller must pass a valid pointer and an index that is in-bounds.
        let tail = unsafe { ptr.add(mid) };
        (
            crate::ptr::slice_from_raw_parts_mut(ptr, mid),
            crate::ptr::slice_from_raw_parts_mut(tail, len - mid),
        )
    }
","pub unsafe fn split_at_mut(self, mid: usize) -> (*mut [T], *mut [T]) {
        assert!(mid <= self.len());
        // SAFETY: The assert above is only a safety-net as long as `self.len()` is correct
        // The actual safety requirements of this function are the same as for `split_at_mut_unchecked`
        unsafe { self.split_at_mut_unchecked(mid) }
    }",The caller has to promise the self is dereferenceable and index is  in-bounds.,complex/nullptr/index,exposed,
../../refs/rust/library/core/src/ptr/mut_ptr.rs,*mut [T],1929,0,"pub unsafe fn get_unchecked_mut<I>(self, index: I) -> *mut I::Output
    where
        I: SliceIndex<[T]>,
    {
        // SAFETY: the caller ensures that `self` is dereferenceable and `index` in-bounds.
        unsafe { index.get_unchecked_mut(self) }
    }",Not found,The caller has to promise the self is dereferenceable and index is  in-bounds.,complex/nullptr/index,exposed,
../../refs/rust/library/core/src/ptr/non_null.rs,NonNull+<T:?Sized>,219,229,"    pub const unsafe fn new_unchecked(ptr: *mut T) -> Self {
        // SAFETY: the caller must guarantee that `ptr` is non-null.
        unsafe {
            assert_unsafe_precondition!(
                check_language_ub,
                ""NonNull::new_unchecked requires that the pointer is non-null"",
                (ptr: *mut () = ptr as *mut ()) => !ptr.is_null()
            );
            NonNull { pointer: ptr as _ }
        }
    }
","
  pub const fn new(ptr: *mut T) -> Option<Self> {
        if !ptr.is_null() {
            // SAFETY: The pointer is already checked and is not null
            Some(unsafe { Self::new_unchecked(ptr) })
        } else {
            None
        }
    }
",Caller has to promise the pointer is non-null.,nullptr,exposed,
../../refs/rust/library/core/src/ptr/non_null.rs,NonNull<[T]>,1564,0,"pub unsafe fn get_unchecked_mut<I>(self, index: I) -> NonNull<I::Output>
    where
        I: SliceIndex<[T]>,
    {
        // SAFETY: the caller ensures that `self` is dereferenceable and `index` in-bounds.
        // As a consequence, the resulting pointer cannot be null.
        unsafe { NonNull::new_unchecked(self.as_ptr().get_unchecked_mut(index)) }
    }",Not found,The caller has to promise the self is dereferenceable and index is  in-bounds.,complex/nullptr/index,exposed,
../../refs/rust/library/core/src/ptr/unique.rs,Unique + <T:?Sized>,88,91,"    pub const unsafe fn new_unchecked(ptr: *mut T) -> Self {
        // SAFETY: the caller must guarantee that `ptr` is non-null.
        unsafe { Unique { pointer: NonNull::new_unchecked(ptr), _marker: PhantomData } }
    }
","pub const fn new(ptr: *mut T) -> Option<Self> {
        if let Some(pointer) = NonNull::new(ptr) {
            Some(Unique { pointer, _marker: PhantomData })
        } else {
            None
        }
    }",Caller has to promise the pointer is non-null.,nullptr,exposed,
../../refs/rust/library/core/src/result.rs,Result,1490,1496,"    pub unsafe fn unwrap_unchecked(self) -> T {
        match self {
            Ok(t) => t,
            // SAFETY: the safety contract must be upheld by the caller.
            Err(_) => unsafe { hint::unreachable_unchecked() },
        }
    }
","unwrap()
unwrap_default()
unwrap_or()
unwrap_or_else()",Caller has to promise the Result is not 'Err'.,Result/Option,exposed,
../../refs/rust/library/core/src/result.rs,Result,1521,1527,"    pub unsafe fn unwrap_err_unchecked(self) -> E {
        match self {
            // SAFETY: the safety contract must be upheld by the caller.
            Ok(_) => unsafe { hint::unreachable_unchecked() },
            Err(e) => e,
        }
    }
","pub fn unwrap_err(self) -> E
    where
        T: fmt::Debug,
    {
        match self {
            Ok(t) => unwrap_failed(""called `Result::unwrap_err()` on an `Ok` value"", &t),
            Err(e) => e,
        }
    }",Caller has to promise the Result is not 'Err'.,Result/Option,exposed,
../../refs/rust/library/core/src/slice/ascii.rs,[u8],43,48,"    pub const unsafe fn as_ascii_unchecked(&self) -> &[ascii::Char] {
        let byte_ptr: *const [u8] = self;
        let ascii_ptr = byte_ptr as *const [ascii::Char];
        // SAFETY: The caller promised all the bytes are ASCII
        unsafe { &*ascii_ptr }
    }
","pub const fn as_ascii(&self) -> Option<&[ascii::Char]> {
        if self.is_ascii() {
            // SAFETY: Just checked that it's ASCII
            Some(unsafe { self.as_ascii_unchecked() })
        } else {
            None
        }
    }",Caller has to promise all the bytes in [u8] are ASCII.,index,exposed,
../../refs/rust/library/core/src/slice/mod.rs,[T],655,0,"pub unsafe fn get_unchecked<I>(&self, index: I) -> &I::Output
    where
        I: SliceIndex<Self>,
    {
        // SAFETY: the caller must uphold most of the safety requirements for `get_unchecked`;
        // the slice is dereferenceable because `self` is a safe reference.
        // The returned pointer is safe because impls of `SliceIndex` have to guarantee that it is.
        unsafe { &*index.get_unchecked(self) }
    }","pub fn get<I>(&self, index: I) -> Option<&I::Output>
    where
        I: SliceIndex<Self>,
    {
        index.get(self)
    }",Caller has to promise the index is in-range.,index,exposed,
../../refs/rust/library/core/src/slice/mod.rs,[T],697,0,"pub unsafe fn get_unchecked_mut<I>(&mut self, index: I) -> &mut I::Output
    where
        I: SliceIndex<Self>,
    {
        // SAFETY: the caller must uphold the safety requirements for `get_unchecked_mut`;
        // the slice is dereferenceable because `self` is a safe reference.
        // The returned pointer is safe because impls of `SliceIndex` have to guarantee that it is.
        unsafe { &mut *index.get_unchecked_mut(self) }
    }","pub fn get_mut<I>(&mut self, index: I) -> Option<&mut I::Output>
    where
        I: SliceIndex<Self>,
    {
        index.get_mut(self)
    }",Caller has to promise the index is in-range.,index,exposed,
../../refs/rust/library/core/src/slice/mod.rs,[T],958,974,"    pub const unsafe fn swap_unchecked(&mut self, a: usize, b: usize) {
        assert_unsafe_precondition!(
            check_library_ub,
            ""slice::swap_unchecked requires that the indices are within the slice"",
            (
                len: usize = self.len(),
                a: usize = a,
                b: usize = b,
            ) => a < len && b < len,
        );

        let ptr = self.as_mut_ptr();
        // SAFETY: caller has to guarantee that `a < self.len()` and `b < self.len()`
        unsafe {
            ptr::swap(ptr.add(a), ptr.add(b));
        }
    }
","
pub const fn swap(&mut self, a: usize, b: usize) {
        // FIXME: use swap_unchecked here (https://github.com/rust-lang/rust/pull/88540#issuecomment-944344343)
        // Can't take two mutable loans from one vector, so instead use raw pointers.
        let pa = &raw mut self[a];
        let pb = &raw mut self[b];
        // SAFETY: `pa` and `pb` have been created from safe mutable references and refer
        // to elements in the slice and therefore are guaranteed to be valid and aligned.
        // Note that accessing the elements behind `a` and `b` is checked and will
        // panic when out of bounds.
        unsafe {
            ptr::swap(pa, pb);
        }
    }
",Caller has to promise the two inputs are both less than self.len().,index,exposed,
../../refs/rust/library/core/src/slice/mod.rs,[T],1312,1323,"    pub const unsafe fn as_chunks_unchecked<const N: usize>(&self) -> &[[T; N]] {
        assert_unsafe_precondition!(
            check_language_ub,
            ""slice::as_chunks_unchecked requires `N != 0` and the slice to split exactly into `N`-element chunks"",
            (n: usize = N, len: usize = self.len()) => n != 0 && len % n == 0,
        );
        // SAFETY: Caller must guarantee that `N` is nonzero and exactly divides the slice length
        let new_len = unsafe { exact_div(self.len(), N) };
        // SAFETY: We cast a slice of `new_len * N` elements into
        // a slice of `new_len` many `N` elements chunks.
        unsafe { from_raw_parts(self.as_ptr().cast(), new_len) }
    }
","pub const fn as_chunks<const N: usize>(&self) -> (&[[T; N]], &[T]) {
        assert!(N != 0, ""chunk size must be non-zero"");
        let len_rounded_down = self.len() / N * N;
        // SAFETY: The rounded-down value is always the same or smaller than the
        // original length, and thus must be in-bounds of the slice.
        let (multiple_of_n, remainder) = unsafe { self.split_at_unchecked(len_rounded_down) };
        // SAFETY: We already panicked for zero, and ensured by construction
        // that the length of the subslice is a multiple of N.
        let array_slice = unsafe { multiple_of_n.as_chunks_unchecked() };
        (array_slice, remainder)
    }",The caller has to promise the N is nom-zero and can exactly divide the slice length.,nonzero/div,exposed,
../../refs/rust/library/core/src/slice/mod.rs,[T],1472,1483,"    pub const unsafe fn as_chunks_unchecked_mut<const N: usize>(&mut self) -> &mut [[T; N]] {
        assert_unsafe_precondition!(
            check_language_ub,
            ""slice::as_chunks_unchecked requires `N != 0` and the slice to split exactly into `N`-element chunks"",
            (n: usize = N, len: usize = self.len()) => n != 0 && len % n == 0
        );
        // SAFETY: Caller must guarantee that `N` is nonzero and exactly divides the slice length
        let new_len = unsafe { exact_div(self.len(), N) };
        // SAFETY: We cast a slice of `new_len * N` elements into
        // a slice of `new_len` many `N` elements chunks.
        unsafe { from_raw_parts_mut(self.as_mut_ptr().cast(), new_len) }
    }
","pub const fn as_chunks_mut<const N: usize>(&mut self) -> (&mut [[T; N]], &mut [T]) {
        assert!(N != 0, ""chunk size must be non-zero"");
        let len_rounded_down = self.len() / N * N;
        // SAFETY: The rounded-down value is always the same or smaller than the
        // original length, and thus must be in-bounds of the slice.
        let (multiple_of_n, remainder) = unsafe { self.split_at_mut_unchecked(len_rounded_down) };
        // SAFETY: We already panicked for zero, and ensured by construction
        // that the length of the subslice is a multiple of N.
        let array_slice = unsafe { multiple_of_n.as_chunks_unchecked_mut() };
        (array_slice, remainder)
    }",The caller has to promise the N is nom-zero and can exactly divide the slice length.,nonzero/div,exposed,
../../refs/rust/library/core/src/slice/mod.rs,[T],1999,2015,"    pub const unsafe fn split_at_unchecked(&self, mid: usize) -> (&[T], &[T]) {
        // FIXME(const-hack): the const function `from_raw_parts` is used to make this
        // function const; previously the implementation used
        // `(self.get_unchecked(..mid), self.get_unchecked(mid..))`

        let len = self.len();
        let ptr = self.as_ptr();

        assert_unsafe_precondition!(
            check_library_ub,
            ""slice::split_at_unchecked requires the index to be within the slice"",
            (mid: usize = mid, len: usize = len) => mid <= len,
        );

        // SAFETY: Caller has to check that `0 <= mid <= self.len()`
        unsafe { (from_raw_parts(ptr, mid), from_raw_parts(ptr.add(mid), unchecked_sub(len, mid))) }
    }
","pub const fn split_at_checked(&self, mid: usize) -> Option<(&[T], &[T])> {
        if mid <= self.len() {
            // SAFETY: `[ptr; mid]` and `[mid; len]` are inside `self`, which
            // fulfills the requirements of `split_at_unchecked`.
            Some(unsafe { self.split_at_unchecked(mid) })
        } else {
            None
        }
    }

or

split_at()",Caller has to promise the mid is between 0 and self.len().,index,exposed,
../../refs/rust/library/core/src/slice/mod.rs,[T],2052,2072,"    pub const unsafe fn split_at_mut_unchecked(&mut self, mid: usize) -> (&mut [T], &mut [T]) {
        let len = self.len();
        let ptr = self.as_mut_ptr();

        assert_unsafe_precondition!(
            check_library_ub,
            ""slice::split_at_mut_unchecked requires the index to be within the slice"",
            (mid: usize = mid, len: usize = len) => mid <= len,
        );

        // SAFETY: Caller has to check that `0 <= mid <= self.len()`.
        //
        // `[ptr; mid]` and `[mid; len]` are not overlapping, so returning a mutable reference
        // is fine.
        unsafe {
            (
                from_raw_parts_mut(ptr, mid),
                from_raw_parts_mut(ptr.add(mid), unchecked_sub(len, mid)),
            )
        }
    }
","pub const fn split_at_mut_checked(&mut self, mid: usize) -> Option<(&mut [T], &mut [T])> {
        if mid <= self.len() {
            // SAFETY: `[ptr; mid]` and `[mid; len]` are inside `self`, which
            // fulfills the requirements of `split_at_unchecked`.
            Some(unsafe { self.split_at_mut_unchecked(mid) })
        } else {
            None
        }
    }


or 


split_at_mut()",Caller has to promise the mid is between 0 and self.len().,index,exposed,
../../refs/rust/library/core/src/slice/mod.rs,[T],4580,0,"pub unsafe fn get_disjoint_unchecked_mut<I, const N: usize>(
        &mut self,
        indices: [I; N],
    ) -> [&mut I::Output; N]
    where
        I: GetDisjointMutIndex + SliceIndex<Self>,
    {
        // NB: This implementation is written as it is because any variation of
        // `indices.map(|i| self.get_unchecked_mut(i))` would make miri unhappy,
        // or generate worse code otherwise. This is also why we need to go
        // through a raw pointer here.
        let slice: *mut [T] = self;
        let mut arr: mem::MaybeUninit<[&mut I::Output; N]> = mem::MaybeUninit::uninit();
        let arr_ptr = arr.as_mut_ptr();

        // SAFETY: We expect `indices` to contain disjunct values that are
        // in bounds of `self`.
        unsafe {
            for i in 0..N {
                let idx = indices.get_unchecked(i).clone();
                arr_ptr.cast::<&mut I::Output>().add(i).write(&mut *slice.get_unchecked_mut(idx));
            }
            arr.assume_init()
        }
    }","pub fn get_disjoint_mut<I, const N: usize>(
        &mut self,
        indices: [I; N],
    ) -> Result<[&mut I::Output; N], GetDisjointMutError>
    where
        I: GetDisjointMutIndex + SliceIndex<Self>,
    {
        get_disjoint_check_valid(&indices, self.len())?;
        // SAFETY: The `get_disjoint_check_valid()` call checked that all indices
        // are disjunct and in bounds.
        unsafe { Ok(self.get_disjoint_unchecked_mut(indices)) }
    }",The caller has to promise the indices is non-overlapping and not OOB.,complex/index,exposed,
../../refs/rust/library/core/src/str/converts.rs,[u8],172,176,"pub const unsafe fn from_utf8_unchecked(v: &[u8]) -> &str {
    // SAFETY: the caller must guarantee that the bytes `v` are valid UTF-8.
    // Also relies on `&str` and `&[u8]` having the same layout.
    unsafe { mem::transmute(v) }
}
","pub const fn from_utf8(v: &[u8]) -> Result<&str, Utf8Error> {
    // FIXME(const-hack): This should use `?` again, once it's `const`
    match run_utf8_validation(v) {
        Ok(_) => {
            // SAFETY: validation succeeded.
            Ok(unsafe { from_utf8_unchecked(v) })
        }
        Err(err) => Err(err),
    }
}",The caller has to promise the bytes are valid UTF-8.,String/Char,exposed,
../../refs/rust/library/core/src/str/converts.rs,str,200,206,"pub const unsafe fn from_utf8_unchecked_mut(v: &mut [u8]) -> &mut str {
    // SAFETY: the caller must guarantee that the bytes `v`
    // are valid UTF-8, thus the cast to `*mut str` is safe.
    // Also, the pointer dereference is safe because that pointer
    // comes from a reference which is guaranteed to be valid for writes.
    unsafe { &mut *(v as *mut [u8] as *mut str) }
}
","pub const fn from_utf8_mut(v: &mut [u8]) -> Result<&mut str, Utf8Error> {
    // FIXME(const-hack): This should use `?` again, once it's `const`
    match run_utf8_validation(v) {
        Ok(_) => {
            // SAFETY: validation succeeded.
            Ok(unsafe { from_utf8_unchecked_mut(v) })
        }
        Err(err) => Err(err),
    }
}",The caller has to promise the bytes are valid UTF-8.,String/Char,exposed,
../../refs/rust/library/core/src/str/mod.rs,str,301,304,"    pub const unsafe fn from_utf8_unchecked(v: &[u8]) -> &str {
        // SAFETY: converts::from_utf8_unchecked has the same safety requirements as this function.
        unsafe { converts::from_utf8_unchecked(v) }
    }
","pub const fn from_utf8(v: &[u8]) -> Result<&str, Utf8Error> {
        converts::from_utf8(v)
    }",The caller has to promise the bytes are valid UTF-8.,String/Char,exposed,
../../refs/rust/library/core/src/str/mod.rs,str,326,329,"    pub const unsafe fn from_utf8_unchecked_mut(v: &mut [u8]) -> &mut str {
        // SAFETY: converts::from_utf8_unchecked_mut has the same safety requirements as this function.
        unsafe { converts::from_utf8_unchecked_mut(v) }
    }
","pub const fn from_utf8_mut(v: &mut [u8]) -> Result<&mut str, Utf8Error> {
        converts::from_utf8_mut(v)
    }",The caller has to promise the bytes are valid UTF-8.,String/Char,exposed,
../../refs/rust/library/core/src/str/mod.rs,[T]+SliceIndex,654,659,"    pub unsafe fn get_unchecked<I: SliceIndex<str>>(&self, i: I) -> &I::Output {
        // SAFETY: the caller must uphold the safety contract for `get_unchecked`;
        // the slice is dereferenceable because `self` is a safe reference.
        // The returned pointer is safe because impls of `SliceIndex` have to guarantee that it is.
        unsafe { &*i.get_unchecked(self) }
    }
","pub fn get<I: SliceIndex<str>>(&self, i: I) -> Option<&I::Output> {
        i.get(self)
    }","The starting index must not exceed the ending index;
Indexes must be within bounds of the original slice;
Indexes must lie on UTF-8 sequence boundaries.",index,exposed,
../../refs/rust/library/core/src/str/mod.rs,[T]+SliceIndex,689,694,"    pub unsafe fn get_unchecked_mut<I: SliceIndex<str>>(&mut self, i: I) -> &mut I::Output {
        // SAFETY: the caller must uphold the safety contract for `get_unchecked_mut`;
        // the slice is dereferenceable because `self` is a safe reference.
        // The returned pointer is safe because impls of `SliceIndex` have to guarantee that it is.
        unsafe { &mut *i.get_unchecked_mut(self) }
    }
","pub fn get_mut<I: SliceIndex<str>>(&mut self, i: I) -> Option<&mut I::Output> {
        i.get_mut(self)
    }","The starting index must not exceed the ending index;
Indexes must be within bounds of the original slice;
Indexes must lie on UTF-8 sequence boundaries.",index,exposed,
../../refs/rust/library/core/src/str/mod.rs,str,740,745,"    pub unsafe fn slice_unchecked(&self, begin: usize, end: usize) -> &str {
        // SAFETY: the caller must uphold the safety contract for `get_unchecked`;
        // the slice is dereferenceable because `self` is a safe reference.
        // The returned pointer is safe because impls of `SliceIndex` have to guarantee that it is.
        unsafe { &*(begin..end).get_unchecked(self) }
    }
",Not found,The caller has to promise the self is dereferenceable and index is  in-bounds.,complex,exposed,
../../refs/rust/library/core/src/str/mod.rs,str,774,779,"    pub unsafe fn slice_mut_unchecked(&mut self, begin: usize, end: usize) -> &mut str {
        // SAFETY: the caller must uphold the safety contract for `get_unchecked_mut`;
        // the slice is dereferenceable because `self` is a safe reference.
        // The returned pointer is safe because impls of `SliceIndex` have to guarantee that it is.
        unsafe { &mut *(begin..end).get_unchecked_mut(self) }
    }
",Not found,The caller has to promise the self is dereferenceable and index is  in-bounds.,complex,exposed,
../../refs/rust/library/portable-simd/crates/core_simd/src/masks.rs,"Mask<T,N>",190,196,"    pub unsafe fn from_int_unchecked(value: Simd<T, N>) -> Self {
        // Safety: the caller must confirm this invariant
        unsafe {
            core::intrinsics::assume(<T as Sealed>::valid(value));
            Self(mask_impl::Mask::from_int_unchecked(value))
        }
    }
","pub fn from_int(value: Simd<T, N>) -> Self {
        assert!(T::valid(value), ""all values must be either 0 or -1"",);
        // Safety: the validity has been checked
        unsafe { Self::from_int_unchecked(value) }
    }",The caller has to promise all elements must be 0 or -1.,vector,exposed,
../../refs/rust/library/portable-simd/crates/core_simd/src/masks.rs,"std::simd::Mask<T,N>",233,236,"    pub unsafe fn test_unchecked(&self, index: usize) -> bool {
        // Safety: the caller must confirm this invariant
        unsafe { self.0.test_unchecked(index) }
    }
","pub fn test(&self, index: usize) -> bool {
        assert!(index < N, ""element index out of range"");
        // Safety: the element index has been checked
        unsafe { self.test_unchecked(index) }
    }",Caller has to promise index is less than self.len().,index,exposed,
../../refs/rust/library/portable-simd/crates/core_simd/src/masks.rs,"std::simd::Mask<T,N>",256,261,"    pub unsafe fn set_unchecked(&mut self, index: usize, value: bool) {
        // Safety: the caller must confirm this invariant
        unsafe {
            self.0.set_unchecked(index, value);
        }
    }
","pub fn set(&mut self, index: usize, value: bool) {
        assert!(index < N, ""element index out of range"");
        // Safety: the element index has been checked
        unsafe {
            self.set_unchecked(index, value);
        }
    }",Caller has to promise index is less than self.len().,index,exposed,
../../refs/rust/library/portable-simd/crates/core_simd/src/vector.rs,"Simd<T,N>",451,0," pub unsafe fn load_select_unchecked(
        slice: &[T],
        enable: Mask<<T as SimdElement>::Mask, N>,
        or: Self,
    ) -> Self {
        let ptr = slice.as_ptr();
        // SAFETY: The safety of reading elements from `slice` is ensured by the caller.
        unsafe { Self::load_select_ptr(ptr, enable, or) }
    }",Not found,,vector,unexposed,
../../refs/rust/library/portable-simd/crates/core_simd/src/vector.rs,"Simd<T,N>",581,0,"pub unsafe fn gather_select_unchecked(
        slice: &[T],
        enable: Mask<isize, N>,
        idxs: Simd<usize, N>,
        or: Self,
    ) -> Self {
        let base_ptr = Simd::<*const T, N>::splat(slice.as_ptr());
        // Ferris forgive me, I have done pointer arithmetic here.
        let ptrs = base_ptr.wrapping_add(idxs);
        // Safety: The caller is responsible for determining the indices are okay to read
        unsafe { Self::gather_select_ptr(ptrs, enable, or) }
    }",Not found,,vector,unexposed,
../../refs/rust/library/portable-simd/crates/core_simd/src/vector.rs,"Simd<T,N>",705,0,"pub unsafe fn store_select_unchecked(
        self,
        slice: &mut [T],
        enable: Mask<<T as SimdElement>::Mask, N>,
    ) {
        let ptr = slice.as_mut_ptr();
        // SAFETY: The safety of writing elements in `slice` is ensured by the caller.
        unsafe { self.store_select_ptr(ptr, enable) }
    }",Not found,,vector,unexposed,
../../refs/rust/library/portable-simd/crates/core_simd/src/vector.rs,"Simd<T,N>",808,0,"pub unsafe fn scatter_select_unchecked(
        self,
        slice: &mut [T],
        enable: Mask<isize, N>,
        idxs: Simd<usize, N>,
    ) {
        // Safety: This block works with *mut T derived from &mut 'a [T],
        // which means it is delicate in Rust's borrowing model, circa 2021:
        // &mut 'a [T] asserts uniqueness, so deriving &'a [T] invalidates live *mut Ts!
        // Even though this block is largely safe methods, it must be exactly this way
        // to prevent invalidating the raw ptrs while they're live.
        // Thus, entering this block requires all values to use being already ready:
        // 0. idxs we want to write to, which are used to construct the mask.
        // 1. enable, which depends on an initial &'a [T] and the idxs.
        // 2. actual values to scatter (self).
        // 3. &mut [T] which will become our base ptr.
        unsafe {
            // Now Entering ?? *mut T Zone
            let base_ptr = Simd::<*mut T, N>::splat(slice.as_mut_ptr());
            // Ferris forgive me, I have done pointer arithmetic here.
            let ptrs = base_ptr.wrapping_add(idxs);
            // The ptrs have been bounds-masked to prevent memory-unsafe writes insha'allah
            self.scatter_select_ptr(ptrs, enable);
            // Cleared ?? *mut T Zone
        }
    }",Not found,,vector,unexposed,
../../refs/rust/library/std/src/collections/hash/map.rs,"HashMap<K,V,S>",1106,0,"pub unsafe fn get_disjoint_unchecked_mut<Q: ?Sized, const N: usize>(
        &mut self,
        ks: [&Q; N],
    ) -> [Option<&'_ mut V>; N]
    where
        K: Borrow<Q>,
        Q: Hash + Eq,
    {
        unsafe { self.base.get_many_unchecked_mut(ks) }
    }","pub fn get_disjoint_mut<Q: ?Sized, const N: usize>(
        &mut self,
        ks: [&Q; N],
    ) -> [Option<&'_ mut V>; N]
    where
        K: Borrow<Q>,
        Q: Hash + Eq,
    {
        self.base.get_many_mut(ks)
    }",The caller has to promise the keys do not overlap.,complex,exposed,
../../refs/rust/library/std/src/ffi/os_str.rs,OsString,183,185,"    pub unsafe fn from_encoded_bytes_unchecked(bytes: Vec<u8>) -> Self {
        OsString { inner: unsafe { Buf::from_encoded_bytes_unchecked(bytes) } }
    }
",Not found,"Each `word` only contains content that originated from `OsStr::as_encoded_bytes`
Only split with ASCII whitespace which is a non-empty UTF-8 substring",complex/str,exposed,
../../refs/rust/library/std/src/ffi/os_str.rs,OsStr,863,865,"    pub unsafe fn from_encoded_bytes_unchecked(bytes: &[u8]) -> &Self {
        Self::from_inner(unsafe { Slice::from_encoded_bytes_unchecked(bytes) })
    }
",Not found,"Each `word` only contains content that originated from `OsStr::as_encoded_bytes`
Only split with ASCII whitespace which is a non-empty UTF-8 substring",complex/str,exposed,
../../refs/rust/library/std/src/sys/os_str/bytes.rs,Buf,108,110,"    pub unsafe fn from_encoded_bytes_unchecked(s: Vec<u8>) -> Self {
        Self { inner: s }
    }
",Not found ,None,unexposed,unexposed,
../../refs/rust/library/std/src/sys/os_str/bytes.rs,Buf,243,245,"    pub unsafe fn from_encoded_bytes_unchecked(s: &[u8]) -> &Slice {
        unsafe { mem::transmute(s) }
    }
",Not found ,None,unexposed,unexposed,
../../refs/rust/library/std/src/sys/os_str/wtf8.rs,Buf,85,87,"    pub unsafe fn from_encoded_bytes_unchecked(s: Vec<u8>) -> Self {
        unsafe { Self { inner: Wtf8Buf::from_bytes_unchecked(s) } }
    }
",Not found ,None,unexposed,unexposed,
../../refs/rust/library/std/src/sys/os_str/wtf8.rs,Slice,222,224,"    pub unsafe fn from_encoded_bytes_unchecked(s: &[u8]) -> &Slice {
        unsafe { mem::transmute(Wtf8::from_bytes_unchecked(s)) }
    }
",Not found ,None,unexposed,unexposed,
../../refs/rust/library/std/src/sys/pal/itron/spin.rs,itron,87,91,"    pub unsafe fn get_unchecked(&self) -> (abi::ID, &T) {
        (self.id.load(Ordering::Acquire) as abi::ID, unsafe {
            (&*self.extra.get()).assume_init_ref()
        })
    }
","pub fn get(&self) -> Option<(abi::ID, &T)> {
        match self.id.load(Ordering::Acquire) {
            ID_UNINIT => None,
            id => Some((id as abi::ID, unsafe { (&*self.extra.get()).assume_init_ref() })),
        }
    }","RTOS的自旋锁相关, 暂不了解",itron,unexposed,
../../refs/rust/library/std/src/sys/pal/itron/spin.rs,itron,95,105,"    pub unsafe fn set_unchecked(&self, (id, extra): (abi::ID, T)) {
        debug_assert!(self.get().is_none());

        // Assumption: A positive `abi::ID` fits in `usize`.
        debug_assert!(id >= 0);
        debug_assert!(usize::try_from(id).is_ok());
        let id = id as usize;

        unsafe { *self.extra.get() = MaybeUninit::new(extra) };
        self.id.store(id, Ordering::Release);
    }
",未找到相关safe,,itron,unexposed,
../../refs/rust/library/std/src/sys/sync/once_box.rs,sync,42,44,"    pub unsafe fn get_unchecked(&self) -> Pin<&T> {
        unsafe { Pin::new_unchecked(&*self.ptr.load(Relaxed)) }
    }
","pub fn get_or_init(&self, f: impl FnOnce() -> Pin<Box<T>>) -> Pin<&T> {
        let ptr = self.ptr.load(Acquire);
        match unsafe { ptr.as_ref() } {
            Some(val) => unsafe { Pin::new_unchecked(val) },
            None => self.initialize(f),
        }
    }",,sync,unexposed,
../../refs/rust/library/std/src/sys_common/wtf8.rs,CodePoint,60,62,"    pub unsafe fn from_u32_unchecked(value: u32) -> CodePoint {
        CodePoint { value }
    }
","pub fn from_u32(value: u32) -> Option<CodePoint> {
        match value {
            0..=0x10FFFF => Some(CodePoint { value }),
            _ => None,
        }
    }",Caller has to promise value is less than or equal to 0x10FFFF.,index,unexposed,
../../refs/rust/library/std/src/sys_common/wtf8.rs,uniode/char,202,204,"    pub unsafe fn from_bytes_unchecked(value: Vec<u8>) -> Wtf8Buf {
        Wtf8Buf { bytes: value, is_known_utf8: false }
    }
",未找到对应的safe,null,complex,unexposed,
../../refs/rust/library/std/src/sys_common/wtf8.rs,unicode/char,626,629,"    pub unsafe fn from_bytes_unchecked(value: &[u8]) -> &Wtf8 {
        // SAFETY: start with &[u8], end with fancy &[u8]
        unsafe { &*(value as *const [u8] as *const Wtf8) }
    }
",未找到对应的safe,null,complex,unexposed,
../../refs/rust/library/std/src/sys_common/wtf8.rs,unicode/char,967,974,"pub unsafe fn slice_unchecked(s: &Wtf8, begin: usize, end: usize) -> &Wtf8 {
    // SAFETY: memory layout of a &[u8] and &Wtf8 are the same
    unsafe {
        let len = end - begin;
        let start = s.as_bytes().as_ptr().add(begin);
        Wtf8::from_bytes_unchecked(slice::from_raw_parts(start, len))
    }
}
",未找到对应的safe,null,complex,unexposed,
../../refs/rust/library/std/src/thread/mod.rs,Builder/thread,461,0,"pub unsafe fn spawn_unchecked<F, T>(self, f: F) -> io::Result<JoinHandle<T>>
    where
        F: FnOnce() -> T,
        F: Send,
        T: Send,
    {
        Ok(JoinHandle(unsafe { self.spawn_unchecked_(f, None) }?))
    }","pub fn spawn<F, T>(f: F) -> JoinHandle<T>
where
    F: FnOnce() -> T,
    F: Send + 'static,
    T: Send + 'static,
{
    Builder::new().spawn(f).expect(""failed to spawn thread"")
}","The caller has to ensure that the spawned thread does not outlive any
references in the supplied thread closure and its return type.",thread,exposed,
